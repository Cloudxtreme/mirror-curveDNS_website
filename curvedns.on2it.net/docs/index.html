<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head profile="http://gmpg.org/xfn/11">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>CurveDNS &raquo; A DNSCurve Forwarding Name Server &raquo; Documentation</title>

<link rel="stylesheet" href="../wp-content/themes/vesper/style.css" type="text/css" media="screen" />
<style type="text/css" media="print">
#sidebar {
	display: none;
}
#footer {
	display: none;
}
</style>

<link rel="alternate" type="application/rss+xml" title="CurveDNS RSS Feed" href="../feed" />
<link rel="pingback" href="http://curvedns.on2it.net/xmlrpc.php" />
<link rel="alternate" type="application/rss+xml" title="CurveDNS &raquo; Documentation Comments Feed" href="feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/curvedns.on2it.net\/wp-includes\/js\/wp-emoji-release.min.js"}};
			!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56812,55356,56807),0,0),c.toDataURL().length>3e3):(d.fillText(String.fromCharCode(55357,56835),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='wp_dlmp_styles-css'  href='../wp-content/plugins/download-monitor/page-addon/styles.css' type='text/css' media='all' />
<link rel='canonical' href='../index.html@p=24.html' />
<link rel='shortlink' href='../index.html@p=24.html' />
	<style type='text/css'>
	.download-info .download-button {
		background-image: url(../wp-content/plugins/download-monitor/page-addon/downloadbutton.gif);
	}
	.download-info .more-button {
		background-image: url(../wp-content/plugins/download-monitor/page-addon/morebutton.gif);
	}
	</style>

</head>
<body>
<div id="wrapper">
	<div id="header">
    	<div id="site-meta">
		<h1><a href="../index.html" title="CurveDNS">CurveDNS</a></h1>
        	<span class="description">A DNSCurve Forwarding Name Server</span>
        </div>
		<div id="topsearch"><form method="get" id="searchform" action="../index.html"><input type="text" value="" name="s" id="s" /><button type="submit">Search</button></form></div>
		<!-- Menu Tabs -->
		<ul id="navigation">
<li><a href="../index.html">Home</a></li>
<li class="page_item page-item-2"><a href="../index.html@p=2.html">About</a></li>
<li class="page_item page-item-24 current_page_item"><a href="../index.html@p=24.html">Documentation</a></li>
<li class="page_item page-item-14"><a href="../index.html@p=14.html">Download</a></li>
<li class="page_item page-item-32"><a href="../index.html@p=32.html">Contact</a></li>
		</ul>	
	</div>
    

	<div id="content">

	
		
			<div class="post">
				<hr style="margin: 0 0 15px 0;" />
				<h2>Documentation</h2>
				<div class="post-entry">
                    	<p>Delivering software is one, giving support on it is another thing. Although DNSCurve is a pretty good understandable protocol, configuring it yourself might give some problems. Therefore this documentation page will help you in turning your regular DNS environment into a DNSCurve capable one. Making you ready for the next secure generation of DNS.</p>
<ol>
<li><strong><a href="../index.html@p=24.html#situation">CurveDNS Situation</a></strong></li>
<li><strong><a href="../index.html@p=24.html#install">Installing CurveDNS as a FreeBSD port</a></strong></li>
<li><strong><a href="../index.html@p=24.html#install">Installing CurveDNS from source</a></strong></li>
<li><strong><a href="../index.html@p=24.html#setup">Setting Up a CurveDNS Environment</a></strong></li>
<li><strong><a href="../index.html@p=24.html#maintenance">Maintaining a CurveDNS Environment</a></strong></li>
<li><strong><a href="../index.html@p=24.html#performance">CurveDNS Performance</a></strong></li>
<li><strong><a href="../index.html@p=24.html#faq">Frequently Asked Questions</a></strong></li>
</ol>
<hr />
<h2><a name="situation">1. CurveDNS Situation</a></h2>
<p>Before actually diving into the relatively technical matters, it is good to have an overview how and where CurveDNS will do its job.</p>
<p>As mentioned on the introduction page, CurveDNS is a DNSCurve capable forwarding DNS server. Meaning that it is able to accept both regular DNS and DNSCurve queries. Forwarding in the sense that it does not have any authoritative data available by itself, it therefore simply forwards an incoming query (received by using either DNS or DNSCurve) towards an authoritative source. In most cases this will be an already existing authoritative name server. Popular software for these services include tinydns, PowerDNS, Microsoft DNS Server, and BIND.</p>
<p>The response received from this authoritative source, will be sent back to the client that contacted the forwarding name server. Whether this is done using regular DNS or DNSCurve of course depends on what type of query came in.</p>
<p>By using this approach, currently existing implementations do not need to be altered. Also administrative software built around these authoritative DNS environments can still be used without major modifications. This hugely influences the speed of deployment. In fact, turning a regular authoritative DNS environment into a DNSCurve capable one, can be done within a few hours.</p>
<p>Remark that CurveDNS is able to forward all the queries that your regular authoritative name server was able to answer. Meaning that it implicitly supports the forwarding of DNSSEC packets, so yes, DNSSEC will work over DNSCurve. Also older DNS related security proposals such as TSIG will still work.</p>
<blockquote class='warning'><p>Notice however that accepting notifies from a limited number of IP addresses will not work in this case. Because your authoritative name server will only see the IP address of the CurveDNS machine as the source IP.</p></blockquote>
<p>A general setup will look like this:</p>
<p>DNS or DNSCurve clients &lt;-&gt; CurveDNS &lt;-&gt; Authoritative name server (tinydns/PowerDNS/&#8230;)</p>
<p>From this small illustration, it can already be seen what kind of information CurveDNS would need to function. The two most important things are the server&#8217;s key pair (i.e. the private- and public key of the server) and the IP address of the authoritative name server. Without these two pieces of information the CurveDNS forwarding software would not be able to run. Of course there are more detailed settings. These will also be explained in this document, nevertheless, first focus lies on getting a CurveDNS setup running.</p>
<blockquote class="tip"><p>Remark that CurveDNS does not need to be installed on a separate machine, it can for example run on the same physical &#8212; or virtual &#8212; machine where the authoritative name server runs on. In this case, the authoritative name server can listen on <code>127.0.0.1</code> or <code>::1</code>. Nevertheless, in case of busy name servers it is recommended to run it on a separate machine.</p></blockquote>
<p>This documentation consists of the following chapters, that explain a whole life-cycle of a CurveDNS environment. Starting with the installation, set up, maintenance, and finally a performance analysis. This documentation is ended by a list of frequently asked questions.</p>
<hr />
<h2><a name="install">2. Installing CurveDNS on FreeBSD</a></h2>
<p>CurveDNS is available as a FreeBSD port: <code>dns/curvedns</code>.</p>
<h2><a name="install">3. Installing CurveDNS from source</a></h2>
<p>As mentioned on CurveDNS&#8217; download page, CurveDNS is currently only being distributed in a source only distribution. This means that you have to compile CurveDNS by yourself, in order to be able to run it. This chapter will explain how to compile CurveDNS and its prerequisites. Furthermore, it will guide you through installing a DNSCurve capable environment.</p>
<h3>3.1. Getting prerequisites</h3>
<p>CurveDNS does not have many prerequisites. Some of them are trivial and mandatory (such as a C compiler), some are a little more complicated and mandatory (like libev), and others make life as a data manager a little bit easier (such as daemontools).</p>
<p>In the list below, you will find a list of prerequisites, together with a definition whether it is truly needed or not.</p>
<ul>
<li> <strong>C-compiler and &#8216;friends&#8217;, mandatory</strong><br />
It goes beyond the scope of this documentation to tell how to install an entire C development platform. Although most systems have a C compiler (and its friends such as a linker, make, etcetera) installed. If you are on a Debian GNU/Linux based system (like Ubuntu), you can install the so called build essentials by running <code>apt-get install build-essential</code>.</li>
<li> <strong>libev, mandatory</strong><br />
<a href="http://software.schmorp.de/pkg/libev.html" target="_blank">libev</a> is a fast library written by Marc Lehmann that eases the usage of watchers on specific events. It also greatly improves independence of platforms, i.e. many platform specific details are handled by libev, instead of CurveDNS. Before installing it from source, it is good to first check whether your system&#8217;s package manager (like apt, ports, yum, etcetera) might have libev available.</p>
<blockquote class="warning"><p>Watch out when looking for libev in your system&#8217;s package manager. There is also a libev<strong>ent</strong>, which is an entirely different library. You really have to look for libev. Under Debian GNU/Linux based systems it can be installed using <code>apt-get install libev-dev</code>.</p></blockquote>
<p>If this is not the case, you will need to compile libev by yourself. Get the latest stable release from <a href="http://dist.schmorp.de/libev/" target="_blank">here</a>. (At the moment of writing that is 3.9.) Further details on installing follows in the section.</li>
<li> <strong>NaCl, mandatory</strong><br />
The <a href="http://nacl.cace-project.eu/" target="_blank">NaCl</a> (Networking and Cryptography library, pronounced &#8216;salt&#8217;) supplies all the cryptographic primitives that DNSCurve &#8212; and thus CurveDNS &#8212; need. You do <em>not</em> have to fetch this, it will be delivered together with CurveDNS&#8217; source. Compilation and installation of this library will be discussed in section 2.4.</li>
<li> <strong>daemontools, recommended</strong><br />
<a href="http://cr.yp.to/daemontools.html" target="_blank">daemontools</a> are a set of tools written by Daniel Bernstein. They greatly simplify the way daemons are handled and maintained. It is not mandatory to install this collection of tools, because almost everything daemontools does, can also be achieved using your system&#8217;s standard tools and some shell scripts. It is however recommended because quite some CurveDNS features can easily be used and configured using daemontools.</p>
<blockquote class="tip"><p>Just as with libev there is a big chance your system&#8217;s package manager already has daemontools in its repository. Be sure to check that first, before installing daemontools from source.</p></blockquote>
<p>If daemontools is not in your package manager&#8217;s repository follow the installation instructions from the deamontools <a href="http://cr.yp.to/daemontools/install.html" target="_blank">install</a> page. If you are having problems with the compilation of daemontools, check out <a href="http://djbware.csi.hu/patches/daemontools-0.76.errno.patch" target="_blank">this</a> page. daemontools will <em>not</em> be discussed in the following sections, compilation and installation is described by deamontools&#8217; <a href="http://cr.yp.to/daemontools/install.html" target="_blank">installation</a> page.</li>
</ul>
<h3>3.2. Installing prerequisites</h3>
<p>This section is only of interest if your system does not have libev in its package repository. So if you have already installed libev you can go to the next section.</p>
<p>Now that the only mandatory prerequisite (libev) is fetched, it is time to compile and install it. This is done as follows:</p>
<pre>(As regular user:)
$ tar -zxvf libev-*.tar.gz
$ cd libev-*
$ ./configure --prefix=/usr
$ make
(As root:)
# make install</pre>
<p>This will install the libev library itself in <code>/usr/lib</code> and the include files in <code>/usr/include</code>. Any program can now dynamically link to libev, which is what CurveDNS is going to do in the next sections.</p>
<p>Like mentioned in the previous section, NaCl will be installed when CurveDNS will. And the installation of daemontools will not be covered in this document &#8212; see previous section.</p>
<h3>3.3. Getting CurveDNS</h3>
<p>Getting CurveDNS isn&#8217;t that hard. Browse to the <a href="../index.html@p=14.html">download</a> page and download the latest stable release, or do it like this:</p>
<pre>$ wget http://curvedns.on2it.net/releases/curvedns-latest.tar.gz</pre>
<p>As mentioned in the previous sections, all releases provide a version of the NaCl library with it. So you do <em>not</em> have to download this by yourself.</p>
<h3>3.4. Compiling CurveDNS</h3>
<p>Once you have obtained a release of CurveDNS it is time to unpack and compile it. This is done as follows:</p>
<pre>$ tar -zxvf curvedns-latest.tar.gz
$ cd curvedns-*</pre>
<p>Now we first are going to compile NaCl. This is done by an entirely separate compile and build process. In fact, it is a very sophisticated piece of software. It will try to compile all the delivered cryptographic primitives several times, every time with different compiler options or specific platform speedups. There are for example primitives that have a special implementation for AMD Athlon CPUs, while others have SPARC specific implementations. In the end it will pick the fastest combination of compiler options and platform speedups. This means you will always get the fastest implementation of a primitive for this specific system.</p>
<p>This compile and selection process is started as follows. Note this can take quite some time. On a modern system around 10 minutes.</p>
<pre>$ ./configure.nacl</pre>
<p>What this command did, is compile a static library file that will be linked with CurveDNS later on. This means that NaCl does <em>not</em> need to be known system-wide. That is also the reason why we deliver NaCl with CurveDNS.</p>
<p>Once this is done, we are ready to configure CurveDNS itself. This is done by running CurveDNS&#8217; configure script.</p>
<pre>$ ./configure.curvedns</pre>
<p>It could be that NaCl was built for different architectures. This is mainly the case for systems that are 64-bit, but have a mode to run programs in a 32-bit environment. If this is the case, the CurveDNS&#8217; configure script will notice this and ask you to select the right one. If you don&#8217;t know what to select, select the 64-bit variant (amd64 in most cases).</p>
<blockquote class="tip"><p>It is also possible to run <code>configure.curvedns</code> with a manually selected ABI. This could be handful to package maintainers. For example, building CurveDNS with <code>amd64</code> support, would work like this: <code>./configure.curvedns amd64</code>. Do however keep in mind that this ABI should of course be available on the system. (Note: this behavior was added in CurveDNS 0.87.)</p></blockquote>
<p>When everything is okay, CurveDNS&#8217; configure script will say it is done and it will state what architecture (ABI), compiler and compiler options will be used. We are now ready to compile CurveDNS. This is done as follows:</p>
<pre>$ make</pre>
<p>This command should run fine. If it does not, please check the <a href="../index.html@p=24.html#faq">FAQ</a> whether someone else might have seen your error before, before sending it to one of CurveDNS&#8217; <a href="../index.html@p=32.html">developers</a>.</p>
<h3>3.5. Installing CurveDNS</h3>
<p>Now that we have compiled the CurveDNS binaries (in fact, there are only two: <code>curvedns</code> and <code>curvedns-keygen</code>), we are ready to install them in an appropriate location. If you run would run the regular <code>make install</code> you will notice nothing is done. CurveDNS does not have a standard place to store its binaries, so it is up to you to install the binaries.</p>
<p>In our believes <code>/usr/local/bin</code> is an appropriate location:</p>
<pre>(As root:)
# cp curvedns curvedns-keygen /usr/local/bin</pre>
<hr />
<h2><a name="setup">4. Setting Up a CurveDNS Environment</a></h2>
<p>This chapter is about to discuss how to setup a CurveDNS environment. It will assume you have configured, compiled, and installed the CurveDNS binaries in a known location, such as <code>/usr/local/bin</code>. Next, it will also assume you have installed the mandatory prerequisites, like libev.</p>
<p>This makes us ready to finally set up the CurveDNS environment. With an environment we mean the directory that keeps all settings for CurveDNS. Such as the keys, and all configuration information. In this chapter the daemontools package can be of great value.</p>
<h3>4.1. Configuration Options</h3>
<p>CurveDNS does <em>not</em> not use a configuration file. Instead, all configuration options are passed via either the command line (startup arguments) or through the program&#8217;s environment. Let&#8217;s first discuss the arguments that must be used to start the CurveDNS server.</p>
<pre>Usage: ./curvedns &lt;listening IPs (sep. by comma)&gt; &lt;listening port&gt; &lt;target DNS server IP&gt; &lt;target DNS server port&gt;</pre>
<p>In short:</p>
<ol>
<li> The IP addresses on which CurveDNS should listen. If you have more IP addresses, separate them by a comma (<code>,</code>). Notice both IPv4 and IPv6 addresses can be used. Also remark that <em>no</em> port number is required. Valid inputs are for example: <code>192.168.0.1</code> and <code>fe80::1,10.3.11.86</code>. If you want CurveDNS to listen on all IP addresses use <code>0.0.0.0</code> (for IPv4 hosts) or <code>::</code> (for IPv6 hosts).</li>
<li> The port number on which CurveDNS should listen. If you want to use a port number beneath 1024, you must be <code>root</code> &#8212; nevertheless, CurveDNS will eventually drop the root privileges once it has done all the tasks that need <code>root</code>.</li>
<li> This is the IP address of the authoritative name server we are forwarding non-DNSCurve queries to. This can be either an IPv4 or IPv6 address.</li>
<li> The port number of the authoritative name server we are forwarding for. Usually this will be 53.</li>
</ol>
<p>You will notice all the above discussed options are mandatory. CurveDNS will complain when some argument is missing.</p>
<p>Now that the arguments options have been discussed, it is time to look at the settings that can be passed using the program&#8217;s environment. We start by discussing the options that are mandatory, i.e. when CurveDNS is started these environment variables must exist.</p>
<ul>
<li> <strong><code>CURVEDNS_PRIVATE_KEY</code></strong>, the hexadecimal representation of the server&#8217;s private (secret) key.</li>
<li> <strong><code>UID</code></strong>, the user id of the user we are switching to when we have done all root specific actions.</li>
<li> <strong><code>GID</code></strong>, the group id of this same user.</li>
</ul>
<p>The following environment options are optional, but might be handy in some cases or when you are very specific in what you want CurveDNS to do. Notice that when you do not specify any of these options in the environment, the suffixing default value will be used.</p>
<ul>
<li> <strong><code>CURVEDNS_INTERNAL_TIMEOUT</code></strong>, number of seconds when to consider the target server has timeout (default: 1.2)</li>
<li> <strong><code>CURVEDNS_UDP_TRIES</code></strong>, total number of tries towards the target server before we drop the query (default: 2)</li>
<li> <strong><code>CURVEDNS_TCP_NUMBER</code></strong>, number of simultaneous TCP connections that are allowed (default: 25)</li>
<li> <strong><code>CURVEDNS_TCP_TIMEOUT</code></strong>, number of seconds before the TCP session to the client times out (default: 60.0)</li>
<li> <strong><code>CURVEDNS_SHARED_SECRETS</code></strong>, number of shared secrets that can be cached (default: 5000)<br />
<blockquote class="tip"><p>The more, the better. It is a good idea to temporarily set the debug level (see next option) to &#8216;debug&#8217; when you alter this value. In this level CurveDNS will show during startup how much memory it reserved for the shared secret cache. In this way you can check whether this will suit your system&#8217;s physical memory boundaries.</p></blockquote>
</li>
<li> <strong><code>CURVEDNS_DEBUG</code></strong>, what information should be shown, i.e. the debug level. The number represents the debug level; 1: fatal, 2: error, 3: warning, 4: info, 5: debug. Less means receiving less information from CurveDNS (default: 2)</li>
<li> <strong><code>CURVEDNS_SOURCE_IP</code></strong>, the IP address CurveDNS will use as source IP address when it will forward the query to the authoritative name server (default: let kernel pick). (This was added in CurveDNS 0.87.)</li>
</ul>
<h3>4.2. Generating Keys</h3>
<p>Now that all options are discussed, it is time to generate a keypair for this CurveDNS instance. The general concept of DNSCurve is to have a key pair for each and every (authoritative) name server. Since CurveDNS is forwarding queries towards a (non-DNSCurve capable) authoritative name server, we generate and maintain this key pair.</p>
<p>This is done as follows:</p>
<pre>$ curvedns-keygen</pre>
<p>You will see that instantly a DNSCurve key will be generated. The output will look like this:</p>
<blockquote class="tip"><p>Because <code>curvedns-keygen</code> uses random data to generate the keypair, each and every run of <code>curvedns-keygen</code> will give entirely different key material.</p></blockquote>
<pre>DNS public key:    uz57bx3x9xp2dqpdfvurvypljbzm8j1fqxdv2s0gvffqcr6351bxvg
Hex public key:    47f5d153af82d9cadad677fb2aa1fa13c1d06c675b60e0766b765d334a507d3b
Hex secret key:    49aa3359894f2a5467aa0cf453f0149a02a3d4e9acf67e146db1a7501340bd20</pre>
<p>The first key is the public part represented using base32-encoding. This key will be used as the forwarding name server&#8217;s name. The second line is the public key part only this time represented in hexadecimal notation. The third line is the private part. This should be the contents of the <strong><code>CURVEDNS_PRIVATE_KEY</code></strong> environment option. It should be clear that this secret key should be protected, it entangles the security for your DNSCurve enabled server. Making a backup (at a secure location of course) is also recommended, because losing the private part of the key would make the server unusable.</p>
<p>Remark that <code>curvedns-keygen</code> does not save any of the information it outputs. So you should be the person to do this. There is however a way to let <code>curvedns-keygen</code> save the information to a certain location. The next section will enlighten this.</p>
<h3>4.3. Running CurveDNS</h3>
<p>Now that the binaries are ready and we have generated a keypair, it is time to start running CurveDNS. For now, we will only focus on running CurveDNS by using <a href="http://cr.yp.to/daemontools.html" target="_blank">daemontools</a>. The only four tools of daemontools we will use are <code>multilog</code>, <code>envdir</code>, <code>setuidgid</code>, and <code>envuidgid</code>. Besides, we will also implicitly use the <code>supervise</code> service to monitor our daemon (so we will write our own <code>run</code> file).</p>
<p>Let&#8217;s create CurveDNS&#8217; working directory, a <code>curvedns</code> user, and setup the log environment.</p>
<pre>(Assuming you are root and you're in CurveDNS' source directory)
# groupadd curvedns
# useradd -g curvedns -s /bin/false -d /etc/curvedns curvedns
# mkdir -p /etc/curvedns/log /etc/curvedns/env
# cp contrib/curvedns-run /etc/curvedns/run
# cp contrib/curvedns-log-run /etc/curvedns/log/run
# chmod 755 /etc/curvedns/run /etc/curvedns/log/run
# chown -R root:root /etc/curvedns
# chown -R curvedns:curvedns /etc/curvedns/log
# chmod 0700 /etc/curvedns/env</pre>
<p>Now edit <code>/etc/curvedns/run</code>. All the five variable lines can be altered to suit your situation.</p>
<p>The <code>env</code> directory will be used to supply environment options towards CurveDNS. Every file in this directory will be transformed to an environment variable, while the contents of the file will act as the environment variable&#8217;s value.</p>
<p>In the previous section we have seen how to generate keys. We have however not shown another way to run <code>curvedns-keygen</code>. This way directly saves a key towards the just created environment directory. The exact usage of <code>curvedns-keygen</code> is therefore:</p>
<pre>Usage: curvedns-keygen &lt;path of CurveDNS installation&gt; &lt;authoritative name server name&gt;</pre>
<p>So if your nameserver is called <code>ns1.example.org</code>, running <code>curvedns-keygen</code> to generate a key for the just created CurveDNS environment works like this:</p>
<pre>(As root)
# curvedns-keygen /etc/curvedns ns1.example.org
Authoritative name server name:
uz5svv9j6p8j05ms321fjtdms06tw23uv5ck1n2650847c8t29up49.ns1.example.org
Hex public key:
78ef044d4510948987080d66363130998ba177593150610a40e42c9445d29524
Hex secret key:
a6b1ca8efeb63024d5e92a356fb8967b091421ad9516006e339dcf495b49e13e

The private key was also written to /etc/curvedns/env/CURVEDNS_PRIVATE_KEY, so it can be used inside CurveDNS environment.</pre>
<p>If you look back at section 3.1, you can specify the environment options in the <code>/etc/curvedns/env</code> directory. So if you want to enable debug mode &#8212; which is recommended to easily test your new installation &#8211;, this works like this:</p>
<pre>$ echo 5 > /etc/curvedns/env/CURVEDNS_DEBUG</pre>
<p>All other <code>CURVEDNS_*</code> environment options can be set like this.</p>
<p>We are now ready to run CurveDNS, so we connect the CurveDNS towards the daemontools supervise service directory.</p>
<blockquote class='warning'><p>The path for this differs on systems. If you installed daemontools from source, it will be <code>/service</code>, while for example Debian related releases have their service directory under <code>/etc/service</code>. So check before running the command below.</p></blockquote>
<pre>ln -s /etc/curvedns /service/curvedns</pre>
<p>In a few seconds <code>curvedns</code> should pop up in your process list. If it does not, please check <code>readproctitle</code> whether any errors occurred (<code>ps ax | grep readproctitle</code>).</p>
<p>Logging of CurveDNS can be found in <code>/etc/curvedns/log/main/current</code>. The main directory is an automatically by <code>multilog</code> rotated log file directory. To see what CurveDNS is doing live, run the following:</p>
<blockquote class='tip'><p>When no specific debug mode (i.e. the <code>DNSCURVE_DEBUG</code> environment variable) has been specified, CurveDNS will only log something when an error occurred. As mentioned before, it is good to temporarily set the debug level to 4, so you can see what is happening.</p></blockquote>
<pre>$ tail -f /etc/curvedns/log/main/current | tai64nlocal</pre>
<p><code>tai64nlocal</code> transforms the TAI timestamp (that <code>multilog</code> adds) to a human readable date. While this is running in a terminal, it is time to test your CurveDNS installation:</p>
<pre>$ dig example.org @127.0.0.1</pre>
<p>If <code>example.org</code> is served by the authoritative name server you are forwarding for and <code>127.0.0.1</code> is the address of this CurveDNS instance. The terminal running the <code>tail</code> should now report several information and you should of course receive a correct answer for the A-type query for <code>example.org</code>.</p>
<h3>4.4. Publishing Keys</h3>
<p>Publishing keys is really easy with DNSCurve. The only thing you have to do is notify an upper zone data manager (probably a registry) that you have a new NS record for your zone.</p>
<p>If your name server was named <code>ns1.example.org</code> before, its DNSCurve enabled name would (for example) be: <code>uz5svv9j6p8j05ms321fjtdms06tw23uv5ck1n2650847c8t29up49.ns1.example.org</code>. (This name is generated by the <code>curvedns-keygen</code> utility.) If you send this name towards the upper zone data manager, it automatically encapsulates your 255-bit public DNSCurve elliptic curve key. Making the world aware your name server is DNSCurve capable.</p>
<p>That&#8217;s really all folks!</p>
<hr />
<h2><a name="maintenance">5. Maintaining a CurveDNS Environment</a></h2>
<p>This chapter discusses how to maintain an already setup CurveDNS environment. It will for example discuss key (both emergency and regular) rollovers. Furthermore, also some special options of the forwarding name server will be discussed. Such as flushing the forwarder&#8217;s internal shared secret table.</p>
<h3>5.1. Daemon Management</h3>
<p>CurveDNS&#8217; actual management is relatively simple. The following three commands specify how to start, stop, and restart CurveDNS respectively.</p>
<blockquote class='warning'><p>The path for the service directory differs on systems. If you installed daemontools from source, it will be <code>/service</code>, while for example Debian related releases have their service directory under <code>/etc/service</code>. So check before running the commands below.</p></blockquote>
<pre># svc -u /service/curvedns
# svc -d /service/curvedns
# svc -t /service/curvedns</pre>
<p>There is also a special option. If you want to flush CurveDNS&#8217; shared secret table &#8212; the table that holds all shared secrets it gathered when it was running &#8212; you can send the CurveDNS process the <code>HUP</code> signal:</p>
<pre># svc -h /service/curvedns</pre>
<p>The last command will give the following message in the log:</p>
<pre>event_signal_cb(): received SIGHUP - clearing cache</pre>
<h3>5.2. Key Management</h3>
<p>(key renewal, etc.)</p>
<p><em>This section is under construction.</em></p>
<hr />
<h2><a name="performance">6. CurveDNS Performance</a></h2>
<p>When programmers, users, and even managers are discussing security, one of the first things that comes to mind is a performance hit due to any of the used cryptographic primitives. To give DNS data managers, DNS users (yes, you are one too, else you wouldn&#8217;t be here), and managers good arguments on this matter a complete chapter of the master thesis focused on CurveDNS has been spent on this matter.</p>
<p><em>This chapter is under construction. For the moment we refer you to section 5.4 of the master thesis <a href="../get/shaping_dns_security_with_curves.pdf">Shaping DNS Security with Curves</a>.</em></p>
<hr />
<h2><a name="faq">7. Frequently Asked Questions</a></h2>
<p>Below you will find all frequently asked questions.</p>
<ul>
<li><strong>Are DNSCurve keys domain based?</strong>
<p>No, they are not. In fact keys used in DNSCurve are server based. Meaning that all domains that are hosted at the same authoritative name server should have the same DNSCurve public key prefix (i.e. uz5&#8230;). An example will clarify this. </p>
<p>Assume you own both <code>example.com</code> and <code>example.org</code> and you host &#8212; to simplify the story a bit &#8212; both domains on one authoritative name server: <code>ns.example.net</code>. If you are putting CurveDNS in front of this name server, you only have to generate one keypair. The name servers of <em>both</em> domains will therefore change to (for example): <code>uz52gs53blkwtykrqpvh4mzf8jqjs278yfd956bgudck6bq5pl9hz2.ns.example.net</code>.</li>
<li><strong>Why did CurveDNS&#8217; initial release get the version number 0.86?</strong>
<p>You might not believe it, but actually there are programmers these days that said &#8216;Hello World&#8217; in 1986.</li>
</ul>
<hr />
<p>Is the question you had in mind not answered at this page at all? Be sure to <a href="../index.html@p=32.html">contact</a> the developers.</p>
<hr />
<small>This page was last updated March 7, 2011 by Jeroen Scheerder.</small></p>
                        				</div>

				<div class="post-info">
							</div>


			</div>

		
	
            
	</div>

	<div id="sidebar">

		<!-- Begin Sidebar -->
		<div>
			<ul>
                    
		<li id="recent-posts-3" class="widget widget_recent_entries">		<h2 class="widgettitle">Recent Posts</h2>		<ul>
					<li>
				<a href="../180/docs.html">CurveDNS Second Public Release: curvedns-0.87</a>
						</li>
					<li>
				<a href="../109/docs/index.html">CurveDNS First Public Release: curvedns-0.86</a>
						</li>
				</ul>
		</li><li id="pages-3" class="widget widget_pages"><h2 class="widgettitle">Pages</h2>		<ul>
			<li class="page_item page-item-2"><a href="../index.html@p=2.html">About</a></li>
<li class="page_item page-item-24 current_page_item"><a href="../index.html@p=24.html">Documentation</a></li>
<li class="page_item page-item-14"><a href="../index.html@p=14.html">Download</a></li>
<li class="page_item page-item-32"><a href="../index.html@p=32.html">Contact</a></li>
		</ul>
		</li><li id="linkcat-3" class="widget widget_links"><h2 class="widgettitle">DNSCurve</h2>
	<ul class='xoxo blogroll'>
<li><a href="http://www.dnscurve.org/" title="The official DNSCurve protocol homepage" target="_blank">DNSCurve.org</a></li>
<li><a href="http://nacl.cr.yp.to/" title="Networking and Cryptography library used by DNSCurve" target="_blank">NaCl</a></li>

	</ul>
</li>
<li id="linkcat-7" class="widget widget_links"><h2 class="widgettitle">Other Implementations</h2>
	<ul class='xoxo blogroll'>
<li><a href="https://github.com/gdnsd/gdnsd" title="gdnsd &#8211; Authoritative name server that supports DNSCurve" target="_blank">gdnsd</a></li>
<li><a href="http://www.dtmf.com/" title="gdnsd DNSCurve Public Testing webpage" target="_blank">gdnsd Public Testing</a></li>

	</ul>
</li>
<li id="linkcat-2" class="widget widget_links"><h2 class="widgettitle">Others</h2>
	<ul class='xoxo blogroll'>
<li><a href="http://on2it.net" title="ON2IT.net delivers managed security solutions to a wide variety of customers." target="_blank">ON2IT.net</a></li>
<li><a href="http://zeroxcool.net/" title="One of the author&#8217;s personal website" target="_blank">zeroxcool.net</a></li>

	</ul>
</li>
			</ul>
		</div>
		<!-- End Sidebar -->
	</div>


	</div>
	<div id="footer_wrap">
		<div id="footer">
			CurveDNS blog is proudly powered by <a href="http://wordpress.org/" target="_blank">WordPress</a> | Designed by: <a href="http://www.valendesigns.com/" target="_blank">Valen Designs LLC</a>
			<div id="rss"> 
				<a href="../feed" id="rss-entries" title="rss entries">rss entries</a>
<!--				<a href="http://curvedns.on2it.net/comments/feed" id="rss-comments" title="rss comments">rss comments</a> -->
			</div>
		</div>
	</div>


	</body>
</html>
